x <- param.list[[i]]
x$setID <- i
if(verbose){
flush.console()
print(paste0(i, " of ", length(param.list)))
}
do.call(cluster.method, x)
}, mc.cores=mc.cores)
cluster.range <- dplyr::bind_rows(cluster.range)
suppressWarnings(cluster.range[,"RangeID" := rangeID])
return(cluster.range)
}
#' Runs an AIC analysis on a range of cluster sets
#' The AIC obtained is based on a predictive model of cluster growth
#' NOTE: The default additional parameter for this analysis is "Time". This may or may not be a row in inputted cluster.range data
#' The default outcome variable is growth. This generally means that this function is expecting a cluster with annotated growth data.
fit.analysis <- function(cluster.data, mc.cores=1, null.formula=Growth~Size, full.formula=Growth~Size+Time,
predictor.model=function(f, x){glm(formula=f, data = x, family="poisson")},
predictor.transformations=list("Time"=function(x){mean(x)})) {
#' @param cluster.data: Inputted set(s) of cluster data. May or may not be sorted into ranges
#' @param mc.cores: A parallel option
#' @param predictor.model: An inputted predictive model function to be used on the data set.
#' @param full.formula: The full model for the prediction of growth. This will be compared to a null Growth~Size model
#' @param predictor.transformations: A named list of transformation functions for each predictor variable
#' @return: A data.table of analysis results. Several important summary values such as null and full AIC are proposed here
#Check inputs
predictors <- names(predictor.transformations)
setIDs <- unique(cluster.data[,SetID])
formula.elements <- unlist(lapply(as.character(full.formula), function(x){strsplit(x, " ")[[1]]}))
if(!all((formula.elements)%in%c(colnames(cluster.data), "+", "~", "-", "*"))){
warning("Predictors for formula may not be in the range of cluster data")
}
if(!all((predictors)%in%colnames(cluster.data))){
stop("Predictors referenced in transform step are not in the range of cluster data")
}
if(!("RangeID"%in%colnames(cluster.data))){
warning("No range ID, by default this will be set to 0 for all sets")
cluster.data[,"RangeID" := 0]
}
if(!("Growth"%in%colnames(cluster.data))){
warning("No Growth information from clusters. By default this will be set to 0 for all sets")
cluster.data[,"Growth" := 0]
}
#Transform cluster data for modelling based on inputs
model.data <- cluster.data[, c("Header", "Size", "Growth", "SetID", "RangeID")]
model.data[, (predictors) := lapply(predictors, function(x){
sapply(cluster.data[, get(x)], function(z){(predictor.transformations[[x]])(z)})
})]
#Obtain fit data for each cluster set
cluster.analysis <- dplyr::bind_rows(
parallel::mclapply(setIDs, function(id) {
DT <- model.data[SetID==id, ]
suppressWarnings(null.fit <- predictor.model(null.formula, DT))
suppressWarnings(full.fit <- predictor.model(full.formula, DT))
res <- data.table::data.table("NullFit"=list(null.fit), "FullFit"=list(full.fit), "SetID"=DT[1,SetID], "RangeID"=DT[1,RangeID])
return(res)
}, mc.cores=mc.cores))
return(cluster.analysis)
}
#'Plots the difference in AIC across the proposed and null models
#'This will reach a central optima, as extremes produce low AIC differences
#'Greater negative values mean larger improvement relative to null model
plot.aic.diff <- function(res){
#'@param res: The result of a fit.analysis() run.
#'@return: A set of AIC differences.
#Check inputs
if(!all(c("NullFit", "FullFit")%in%colnames(res))){
stop("NullFit and FullFit are not names in result output. Ensure that fit.analysis() was run to
obtain the result plotted here.")
}
#Get AIC info and create plot
null.aic <- sapply(res$NullFit, function(x){x$aic})
full.aic <- sapply(res$FullFit, function(x){x$aic})
aic.diff <- full.aic-null.aic
par(mfrow=c(2, 1), mar = c(0,4.2,1,2), cex.lab=1.2)
plot(x=res$SetID, type="n", ylim=c(0, max(c(null.aic,full.aic))),
xlab="", ylab="Akaike's Information Criterion", xaxt='n')
#Background
bg <- par('usr')
rect(xl=bg[1], yb=bg[3], xr=bg[2], yt=bg[4], col='blanchedalmond', border=NA)
abline(h=axTicks(side=2), col='white', lwd=3, lend=2)
abline(h=axTicks(side=2)+diff(axTicks(side=2))[1]/2, col='white', lend=2)
abline(v=axTicks(side=1), col='white', lwd=3, lend=2)
abline(v=axTicks(side=1)+diff(axTicks(side=1))[1]/2, col='white', lend=2)
abline(h=0)
#Plot Profile with minimum located
abline(v=which.min(aic.diff), lty=3, lwd=2)
polygon(c(0, res$SetID, max(res$SetID)), c(0, full.aic, 0) , col=rgb(1,0,0,0.4))
polygon(c(0, res$SetID, max(res$SetID)), c(0, null.aic, 0) , col=rgb(0,1,1,0.4))
legend("topright", bg="white",
legend=c("Full Model", "Null Model", "Overlap"),
fill=c(rgb(1,0,0,0.4), rgb(0,1,1,0.4), rgb(0,0.65,0.65,0.7)))
#Plot aic.diff
par(mar=c(5,4.2,1,2))
plot(x=res$SetID, type="n", ylim=c(min(aic.diff), max(aic.diff)),
xlab="SetID", ylab="Difference")
#Background
bg <- par('usr')
rect(xl=bg[1], yb=bg[3], xr=bg[2], yt=bg[4], col='blanchedalmond', border=NA)
abline(h=axTicks(side=2), col='white', lwd=3, lend=2)
abline(h=axTicks(side=2)+diff(axTicks(side=2))[1]/2, col='white', lend=2)
abline(v=axTicks(side=1), col='white', lwd=3, lend=2)
abline(v=axTicks(side=1)+diff(axTicks(side=1))[1]/2, col='white', lend=2)
#Plot difference with minimum located
lines(res$SetID, aic.diff, lwd=1.6, col="orangered")
points(res$SetID, aic.diff)
abline(h=0)
abline(v=which.min(aic.diff), lty=3, lwd=2)
text(x=max(res$SetID), y=min(aic.diff), adj=c(1,0), cex=1.2,
paste0("Highest Loss: ", round(min(aic.diff)),"\nat SetID: ", which.min(aic.diff)))
return(aic.diff)
}
#' Runs a given clustering method over a range of parameters values.
multi.cluster <- function(cluster.method, param.list, mc.cores = 1, verbose = T, rangeID = 0) {
#' @param param.list: A named list of parameter sets. Each must correspond to the clustering method used.
#' @param rangeID: If several different parameter ranges are used, the rangeID can identify them.
#' @param mc.cores: A parallel option
#' @param verbose: An output monitoring option
#' @return: A larger data.table with parameter sets noted
# Cluster method loop
cluster.range <- parallel::mclapply(1:length(param.list), function(i) {
x <- param.list[[i]]
x$setID <- i
if (verbose) {
flush.console()
print(paste0(i, " of ", length(param.list)))
}
do.call(cluster.method, x)
}, mc.cores = mc.cores)
cluster.range <- dplyr::bind_rows(cluster.range)
suppressWarnings(cluster.range[, "RangeID" := rangeID])
return(cluster.range)
}
#' Runs an AIC analysis on a range of cluster sets
#' The AIC obtained is based on a predictive model of cluster growth
#' NOTE: The default additional parameter for this analysis is "Time". This may or may not be a row in inputted cluster.range data
#' The default outcome variable is growth. This generally means that this function is expecting a cluster with annotated growth data.
fit.analysis <- function(cluster.data, mc.cores = 1, null.formula = Growth ~ Size, full.formula = Growth ~ Size + Time,
predictor.model = function(f, x) {
glm(formula = f, data = x, family = "poisson")
},
predictor.transformations = list("Time" = function(x) {
mean(x)
})) {
#' @param cluster.data: Inputted set(s) of cluster data. May or may not be sorted into ranges
#' @param mc.cores: A parallel option
#' @param predictor.model: An inputted predictive model function to be used on the data set.
#' @param full.formula: The full model for the prediction of growth. This will be compared to a null Growth~Size model
#' @param predictor.transformations: A named list of transformation functions for each predictor variable
#' @return: A data.table of analysis results. Several important summary values such as null and full AIC are proposed here
# Check inputs
predictors <- names(predictor.transformations)
setIDs <- unique(cluster.data[, SetID])
formula.elements <- unlist(lapply(as.character(full.formula), function(x) {
strsplit(x, " ")[[1]]
}))
if (!all((formula.elements) %in% c(colnames(cluster.data), "+", "~", "-", "*"))) {
warning("Predictors for formula may not be in the range of cluster data")
}
if (!all((predictors) %in% colnames(cluster.data))) {
stop("Predictors referenced in transform step are not in the range of cluster data")
}
if (!("RangeID" %in% colnames(cluster.data))) {
warning("No range ID, by default this will be set to 0 for all sets")
cluster.data[, "RangeID" := 0]
}
if (!("Growth" %in% colnames(cluster.data))) {
warning("No Growth information from clusters. By default this will be set to 0 for all sets")
cluster.data[, "Growth" := 0]
}
# Transform cluster data for modelling based on inputs
model.data <- cluster.data[, c("Header", "Size", "Growth", "SetID", "RangeID")]
model.data[, (predictors) := lapply(predictors, function(x) {
sapply(cluster.data[, get(x)], function(z) {
(predictor.transformations[[x]])(z)
})
})]
# Obtain fit data for each cluster set
cluster.analysis <- dplyr::bind_rows(
parallel::mclapply(setIDs, function(id) {
DT <- model.data[SetID == id, ]
suppressWarnings(null.fit <- predictor.model(null.formula, DT))
suppressWarnings(full.fit <- predictor.model(full.formula, DT))
res <- data.table::data.table("NullFit" = list(null.fit), "FullFit" = list(full.fit), "SetID" = DT[1, SetID], "RangeID" = DT[1, RangeID])
return(res)
}, mc.cores = mc.cores)
)
return(cluster.analysis)
}
#' Plots the difference in AIC across the proposed and null models
#' This will reach a central optima, as extremes produce low AIC differences
#' Greater negative values mean larger improvement relative to null model
plot.aic.diff <- function(res) {
#' @param res: The result of a fit.analysis() run.
#' @return: A set of AIC differences.
# Check inputs
if (!all(c("NullFit", "FullFit") %in% colnames(res))) {
stop("NullFit and FullFit are not names in result output. Ensure that fit.analysis() was run to
obtain the result plotted here.")
}
# Get AIC info and create plot
null.aic <- sapply(res$NullFit, function(x) {
x$aic
})
full.aic <- sapply(res$FullFit, function(x) {
x$aic
})
aic.diff <- full.aic - null.aic
par(mfrow = c(2, 1), mar = c(0, 4.2, 1, 2), cex.lab = 1.2)
plot(
x = res$SetID, type = "n", ylim = c(0, max(c(null.aic, full.aic))),
xlab = "", ylab = "Akaike's Information Criterion", xaxt = "n"
)
# Background
bg <- par("usr")
rect(xl = bg[1], yb = bg[3], xr = bg[2], yt = bg[4], col = "blanchedalmond", border = NA)
abline(h = axTicks(side = 2), col = "white", lwd = 3, lend = 2)
abline(h = axTicks(side = 2) + diff(axTicks(side = 2))[1] / 2, col = "white", lend = 2)
abline(v = axTicks(side = 1), col = "white", lwd = 3, lend = 2)
abline(v = axTicks(side = 1) + diff(axTicks(side = 1))[1] / 2, col = "white", lend = 2)
abline(h = 0)
# Plot Profile with minimum located
abline(v = which.min(aic.diff), lty = 3, lwd = 2)
polygon(c(0, res$SetID, max(res$SetID)), c(0, full.aic, 0), col = rgb(1, 0, 0, 0.4))
polygon(c(0, res$SetID, max(res$SetID)), c(0, null.aic, 0), col = rgb(0, 1, 1, 0.4))
legend("topright",
bg = "white",
legend = c("Full Model", "Null Model", "Overlap"),
fill = c(rgb(1, 0, 0, 0.4), rgb(0, 1, 1, 0.4), rgb(0, 0.65, 0.65, 0.7))
)
# Plot aic.diff
par(mar = c(5, 4.2, 1, 2))
plot(
x = res$SetID, type = "n", ylim = c(min(aic.diff), max(aic.diff)),
xlab = "SetID", ylab = "Difference"
)
# Background
bg <- par("usr")
rect(xl = bg[1], yb = bg[3], xr = bg[2], yt = bg[4], col = "blanchedalmond", border = NA)
abline(h = axTicks(side = 2), col = "white", lwd = 3, lend = 2)
abline(h = axTicks(side = 2) + diff(axTicks(side = 2))[1] / 2, col = "white", lend = 2)
abline(v = axTicks(side = 1), col = "white", lwd = 3, lend = 2)
abline(v = axTicks(side = 1) + diff(axTicks(side = 1))[1] / 2, col = "white", lend = 2)
# Plot difference with minimum located
lines(res$SetID, aic.diff, lwd = 1.6, col = "orangered")
points(res$SetID, aic.diff)
abline(h = 0)
abline(v = which.min(aic.diff), lty = 3, lwd = 2)
text(
x = max(res$SetID), y = min(aic.diff), adj = c(1, 0), cex = 1.2,
paste0("Highest Loss: ", round(min(aic.diff)), "\nat SetID: ", which.min(aic.diff))
)
return(aic.diff)
}
param.list.tn93 <- lapply(seq(0,0.01,0.0001), function(x){list("g"=g.tn93, "dist.thresh"=x)})
param.list.patristic <- lapply(seq(0,0.08,0.001), function(x){list("g"=g.patristic, "dist.thresh"=x)})
cluster.range.tn93 <- multi.cluster(component.cluster, param.list.tn93, mc.cores = 4)
cluster.range.patristic <- multi.cluster(component.cluster, param.list.patristic, mc.cores = 4)
res.tn93 <- fit.analysis(cluster.range.tn93)
res.patristic <- fit.analysis(cluster.range.patristic)
plot.aic.diff(res.tn93)
param.list.tn93[[which.min()]]
aicdiff.tn93 <- plot.aic.diff(res.tn93)
param.list.tn93[[which.min(aicdiff.tn93)]]
plot.aic.diff(res.patristic)
aicdiff.patristic <- plot.aic.diff(res.patristic)
param.list.patristic[[which.min(aicdiff.patristic)]]
param.list.tn93[[which.min(aicdiff.tn93)]]
aicdiff.tn93 <- plot.aic.diff(res.tn93)
#### PPLACER/TREE TESTING
stats.json.ft.test <- translate.log(log.file = "test_full_log_FastTree.txt", program = "FastTree")
#### PPLACER/TREE TESTING
stats.json.ft.test <- translate.log(log.file = "data/FastTree_LogEx.txt", program = "FastTree")
stats.json.rml.test <- translate.log(log.file = "data/RAxML_LogEx.txt", program = "RAxML")
stats.json <- translate.log(log.file = "test_old_log_IQTREE.txt", program = "IQ-TREE")
stats.json <- translate.log(log.file = "data/IQTREE_old.tree_Log.txt", program = "IQ-TREE")
refpkg <- taxit.create(t.old, seqs.full, stats.json)
refpkg <- taxit.create(tree.old, seqs.full, stats.json)
#### PPLACER/TREE TESTING
stats.json.ft.test <- translate.log(log.file = "data/FastTree_LogEx.txt", program = "FastTree")
stats.json.rml.test <- translate.log(log.file = "data/RAxML_LogEx.txt", program = "RAxML")
stats.json <- translate.log(log.file = "data/IQTREE_old.tree_Log.txt", program = "IQ-TREE")
refpkg <- taxit.create(tree.old, seqs.full, stats.json)
t <- tree.old
locus = "LOCUS"
# Set up and populate temporary file system
refpkg <- tempdir()
seq.file <- paste0(refpkg, "/seq.fasta")
seq.file.name <- tail(strsplit(seq.file, "/")[[1]], 1)
ape::write.FASTA(seqs.full, "test.fasta")
ape::write.FASTA(seqs.full, seq.file)
stats.file <- paste0(refpkg, "/stats.json")
stats.file.name <- tail(strsplit(stats.file, "/")[[1]], 1)
con <- file(stats.file)
write(stats.json, con)
close(con)
tree.file <- paste0(refpkg, "/tree.nwk")
tree.file.name <- tail(strsplit(tree.file, "/")[[1]], 1)
ape::write.tree(t, tree.file)
log.file <- paste0(refpkg, "/log.txt")
log.file.name <- tail(strsplit(log.file, "/")[[1]], 1)
write("Sample log file. Created Using taxit.create() wrapper")
log.file <- paste0(refpkg, "/log.txt")
log.file.name <- tail(strsplit(log.file, "/")[[1]], 1)
conn <- file(log.file)
write("Sample log file. Created Using taxit.create() wrapper",conn)
close(conn)
# Create generic JSON summary for refpkg.
summary.json <- jsonlite::toJSON(list(
"files" = list(
"aln_fasta" = seq.file.name,
"phylo_model" = stats.file.name,
"tree" = tree.file.name,
"tree_stats" = log.file.name
),
"rollback" = NULL,
"log" = c(
"Stripped refpkg (removed 0 files)",
"Loaded initial files into empty refpkg"
),
"metadata" = list(
"create_date" = as.character(Sys.Date()),
"format_version" = "1.1",
"locus" = locus
),
"rollforward" = NULL,
"md5" = list(
"aln_fasta" = digest::digest(seq.file.name, algo = "md5"),
"phylo_model" = digest::digest(stats.file.name, algo = "md5"),
"tree" = digest::digest(tree.file.name, algo = "md5"),
"tree_stats" = digest::digest(log.file.name, algo = "md5")
)
), pretty = T, always_decimal = T, auto_unbox = T)
summary.file <- paste0(refpkg, "/CONTENTS.json")
con <- file(summary.file)
write(summary.json, summary.file)
close(con)
#' Parses the logfile output of tree building software to find information relevant to pplacer.
#' Prints stats to a temporary ref.pkg file and returns the path to that file.
#'
#' NOTE: Currently compatible with GTR substitution model and either FastTree or IQ-TREE logfiles.
#' Working to extend this to PhyML logfiles, and then to different models of evolution
translate.log <- function(log.file, program, substitution.model = "GTR") {
#' @param log.file: A path to the logfile from a tree construction run
#' @param program: The software used to build the tree.
#' Can be "FastTree", "RAxML" or "IQ-TREE".
#' @param substitution.model: The substitution model used. Currently only accepts "GTR"
#' @return: a json output to be written to a given stats.file for pplacer
# Open connection to log.file
con <- file(log.file)
lns <- readLines(con)
close(con)
# Extracts and normalizes list of frequencies
## TO-DO: PhyML not implemented ()
if (program %in% "FastTree") {
p <- "GTRRates"
s <- lns[grep(p, lns)]
s <- strsplit(s, "\t")[[1]]
s <- as.numeric(s[c(2, 3, 4, 5, 6, 7)])
}
if (program %in% "IQ-TREE") {
p <- "Rate parameters"
s <- lns[grep(p, lns)]
s <- strsplit(s[length(s)], " ")[[1]]
s <- as.numeric(s[c(5, 20, 11, 8, 14, 17)])
}
if (program %in% "RAxML") {
p <- " rates"
s <- lns[grep(p, lns)]
s <- strsplit(s[length(s)], " ")[[1]]
s <- as.numeric(s[c(10, 15, 12, 11, 13, 14)])
}
# Write stats information to .json
stats.json <- jsonlite::toJSON(list(
"empirical_frequencies" = TRUE,
"datatype" = "DNA",
"subs_model" = substitution.model,
"program" = program,
## -TO-DO: Test Correctness of gamma assumption -##
"ras_model" = "gamma",
"gamma" = list(
"alpha" = 1.0,
"n_cats" = as.integer(20)
),
"subs_rates" = list(
"ac" = s[1],
"gt" = s[2],
"at" = s[3],
"ag" = s[4],
"cg" = s[5],
"ct" = s[6]
)
), pretty = T, always_decimal = T, auto_unbox = T)
return(stats.json)
}
#' A wrapper for the taxit create function used by pplacer. This will generate a summary json
#' See pplacer's basic function regarding alignments and tree function
#' NOTE: Creates temporary files. These are only deleted with the end of the session
taxit.create <- function(t, seqs.full, stats.json, locus = "LOCUS") {
#' @param t: The tree (made on a subset of the full alignment)
#' @param seqs.full: The full alignment. Including sequences excluded from the tree.
#' @param stats.json: Path to the full alignment file (new + old seqs)
#' @param locus: Extra information required for the summary json
#' @return: Path to a temporary refpkg directory
# Set up and populate temporary file system
refpkg <- tempdir()
seq.file <- paste0(refpkg, "/seq.fasta")
seq.file.name <- tail(strsplit(seq.file, "/")[[1]], 1)
ape::write.FASTA(seqs.full, seq.file)
stats.file <- paste0(refpkg, "/stats.json")
stats.file.name <- tail(strsplit(stats.file, "/")[[1]], 1)
conn <- file(stats.file)
write(stats.json, conn)
close(conn)
tree.file <- paste0(refpkg, "/tree.nwk")
tree.file.name <- tail(strsplit(tree.file, "/")[[1]], 1)
ape::write.tree(t, tree.file)
log.file <- paste0(refpkg, "/log.txt")
log.file.name <- tail(strsplit(log.file, "/")[[1]], 1)
conn <- file(log.file)
write("Sample log file. Created Using taxit.create() wrapper",conn)
close(conn)
# Create generic JSON summary for refpkg.
summary.json <- jsonlite::toJSON(list(
"files" = list(
"aln_fasta" = seq.file.name,
"phylo_model" = stats.file.name,
"tree" = tree.file.name,
"tree_stats" = log.file.name
),
"rollback" = NULL,
"log" = c(
"Stripped refpkg (removed 0 files)",
"Loaded initial files into empty refpkg"
),
"metadata" = list(
"create_date" = as.character(Sys.Date()),
"format_version" = "1.1",
"locus" = locus
),
"rollforward" = NULL,
"md5" = list(
"aln_fasta" = digest::digest(seq.file.name, algo = "md5"),
"phylo_model" = digest::digest(stats.file.name, algo = "md5"),
"tree" = digest::digest(tree.file.name, algo = "md5"),
"tree_stats" = digest::digest(log.file.name, algo = "md5")
)
), pretty = T, always_decimal = T, auto_unbox = T)
summary.file <- paste0(refpkg, "/CONTENTS.json")
con <- file(summary.file)
write(summary.json, summary.file)
close(con)
return(refpkg)
}
#' A wrapper for pplacer's basic run function coupled with guppy's sing function.
#' Together, these extend fixed trees with most likely placement locations.
#' TODO: Include package binaries such that it is not a requirement to install both pplacer and guppy
run.pplacer_guppy <- function(refpkg) {
#' @param refpkg: A reference package to use as input for pplacer
#' @return: A set of trees, each containing 1 new sequence.
# Run pplacer to obtain placements
system(paste0(
"export LC_ALL=C ; ", "pplacer -c ", refpkg,
" -o ", refpkg, "/placements.jplace",
" ", refpkg, "/seq.fasta"
))
# Run guppy to obtain trees
system(paste0(
"guppy sing ", refpkg, "/placements.jplace",
" -o ", refpkg, "/growth.tre"
))
ts <- ape::read.tree(paste0(refpkg, "/growth.tre"))
return(ts)
}
refpkg <- taxit.create(tree.old, seqs.full, stats.json)
tree.grown  <- run.pplacer_guppy(refpkg)
mc.cores <- 4
t <- extend.tree(t, seq.info, mc.cores=mc.cores)
tree.extended <- extend.tree(tree.old, seq.info, mc.cores=mc.cores)
tree.extended$growth.info <- annotate.growth(tree.extended, tree.grown, mc.cores=mc.cores)
clusters.step <- step.cluster(t, 0.007, 0.3)
clusters.step <- step.cluster(tree.extended, 0.007, 0.3)
clusters.mono <- mono.pat.cluster(tree.extended, 0.07, 0.3)
param.list <- lapply(seq(0,0.04,0.001), function(x){list("t"=t, "branch.thresh"=x)})
cluster.range <- multi.cluster(step.cluster, param.list, mc.cores = 4)
param.list <- lapply(seq(0,0.04,0.001), function(x){list("t"=tree.extended, "branch.thresh"=x)})
cluster.range <- multi.cluster(step.cluster, param.list, mc.cores = 4)
cluster.data <- cluster.range
data.table::setnames(cluster.range, "CollectionDate", "Time")
cluster.range <- multi.cluster(step.cluster, param.list, mc.cores = 4)
data.table::setnames(cluster.range, "CollectionDate", "Time")
cluster.range <- multi.cluster(step.cluster, param.list, mc.cores = 4)
res <- fit.analysis(cluster.range)
plot.aic.diff(res)
devtools::load_all()
devtools::load_all()
load("data/test_data.RData")
devtools::load_all()
devtools::load_all()
source("test.script.R")
seq.info <- pull.headers(seqs.full,var.names = c("ID", "CollectionDate", "Subtype"),
var.transformations =list(as.character, as.Date, as.factor))
seq.info
seq.info <- pull.headers(seqs.full,var.names = c("ID", "CollectionDate", "Subtype"),
var.transformations =list(as.character, as.Date, as.factor))
devtools::load_all()
devtools::load_all()
devtools::load_all()
devtools::load_all()
devtools::load_all()
devtools::load_all()
devtools::load_all()
