#' Multiple clusters from a parameter set
#'
#' Runs a given clustering method over a range of parameters values to output
#' a range of cluster sets corresponding to different
#'
#' @param cluster.method: A given clustering function such as step.cluster() which produces a set of clusters
#' @param param.list: A named list of parameter sets, which can act as inputs to cluster.method.
#' @param rangeID: A unique identifier for the set of rows generated by this run.
#' If this output is bound to other cluster ranges in a larger analysis, this can disambiguate
#' @param mc.cores: A parallel option to increase run speed.
#' @return A data.table with parameter sets and cluster IDs specified
#' @export
#' @examples
#'
multi.cluster <- function(cluster.method, param.list, mc.cores = 1, rangeID = 0) {

  # Cluster method loop
  cluster.range <- parallel::mclapply(1:length(param.list), function(i) {
    x <- param.list[[i]]
    x$setID <- i
    suppressWarnings(do.call(cluster.method, x))
  }, mc.cores = mc.cores)

  cluster.range <- dplyr::bind_rows(cluster.range)
  suppressWarnings(cluster.range[, "RangeID" := rangeID])

  return(cluster.range)
}

#' Predictive analysis on clusters
#'
#' Fits a predictive model of some outcome (by default, cluster growth) to sets of cluster data.
#' These fits are recorded for each use of the predictive model on a given cluster set
#'
#' @param cluster.data: Inputted set(s) of clusters May or may not be sorted into ranges
#' @param mc.cores: A parallel option to increase run speed
#' @param predictor.transformations: A named list of transformation functions for each predictor variable.
#' This name should correspond to a column from the cluster.data, which will be taken as input for the function.
#' for example list("CollectionDate"=mean), would change the collection date column to a vector of means
#' instead of a list collection date vectors
#' @param predictive.models: A named list of functions, each of which applies a model to inputted data (x). See default null for example.
#' @return A data.table of analysis results. Several important summary values such as null and full AIC are proposed here.
#' @export
fit.analysis <- function(cluster.data, mc.cores = 1, predictor.transformations = list(),
                         predictive.models = list(
                           "NullModel" = function(x){
                             glm(Size~Growth, data=x, family="poisson")
                             })) {
  # Check inputs
  predictors <- names(predictor.transformations)
  mod.names <- names(predictive.models)
  setIDs <- unique(cluster.data[, SetID])
  if (!all((predictors) %in% colnames(cluster.data))) {
    stop("Predictors referenced in transform step are not in the range of cluster data")
  }
  if (!("RangeID" %in% colnames(cluster.data))) {
    warning("No range ID, by default this will be set to 0 for all sets")
    cluster.data[, "RangeID" := 0]
  }

  # Transform cluster data for modelling based on inputs
  model.data <- cluster.data[, c("Header", "Size", "Growth", "SetID", "RangeID")]

  if(!is.null(predictors)) {
    model.data[, (predictors) := lapply(predictors, function(x) {
      sapply(cluster.data[, get(x)], function(z) {
        (predictor.transformations[[x]])(z)
      })
    })]
  }


  # Obtain fit data for each cluster set
  cluster.analysis <- dplyr::bind_rows(
    parallel::mclapply(setIDs, function(id) {
      DT <- model.data[SetID == id, ]

      res <- data.table::data.table("SetID" = DT[1, SetID], "RangeID" = DT[1, RangeID])
      res[, (mod.names) := lapply(predictive.models, function(pmod){
        suppressWarnings(list(pmod(DT)))
      })]
      return(res)
    }, mc.cores = mc.cores)
  )

  return(cluster.analysis)
}

#'Get AIC values from an analysis
#'
#'Takes a cluster.analysis and extracts AIC values from columns containing model fits.
#'Model fit columns are automatically identified
#'
#'@param cluster.analysis: A data.table from some predictive growth model analysis generated by fit.analysis()
#'@return The AIC data for all columns containing fit objects
#'@export
get.AIC <- function(cluster.analysis){

  #Identify models
  which.models <- sapply(cluster.analysis[1,], function(x){any(attr(x[[1]], "class")%in%c("lm", "glm"))})
  which.models <- which(which.models)
  if(length(which.models)==0) {
    stop("No models in the data set provided")
  }
  model.fits <- cluster.analysis[,.SD, .SDcols = which.models]

  #Return specifically aic as a new data.table
  newnms <- sapply(names(which.models), function(nm){paste0(nm,"AIC")})
  aic.analysis <- data.table::data.table()
  aic.analysis[,(newnms) := lapply(names(which.models), function(nm){
    sapply(model.fits[,get(nm)], function(x){x$aic})
  })]

  return(aic.analysis)
}
